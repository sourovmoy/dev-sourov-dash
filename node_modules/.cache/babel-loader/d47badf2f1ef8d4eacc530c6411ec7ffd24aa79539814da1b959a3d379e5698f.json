{"ast":null,"code":"import _objectSpread from \"C:/Assigment/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { frame, isPrimaryPointer, cancelFrame, frameData } from 'motion-dom';\nimport { pipe, secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\nimport { extractEventInfo } from '../../events/event-info.mjs';\nimport { distance2D } from '../../utils/distance.mjs';\n\n/**\n * @internal\n */\nclass PanSession {\n  constructor(event, handlers) {\n    let {\n      transformPagePoint,\n      contextWindow = window,\n      dragSnapToOrigin = false,\n      distanceThreshold = 3\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    /**\n     * @internal\n     */\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n    this.handlers = {};\n    /**\n     * @internal\n     */\n    this.contextWindow = window;\n    this.updatePoint = () => {\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n      const info = getPanInfo(this.lastMoveEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null;\n      // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursor.\n      const isDistancePastThreshold = distance2D(info.offset, {\n        x: 0,\n        y: 0\n      }) >= this.distanceThreshold;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      const {\n        point\n      } = info;\n      const {\n        timestamp\n      } = frameData;\n      this.history.push(_objectSpread(_objectSpread({}, point), {}, {\n        timestamp\n      }));\n      const {\n        onStart,\n        onMove\n      } = this.handlers;\n      if (!isPanStarted) {\n        onStart && onStart(this.lastMoveEvent, info);\n        this.startEvent = this.lastMoveEvent;\n      }\n      onMove && onMove(this.lastMoveEvent, info);\n    };\n    this.handlePointerMove = (event, info) => {\n      this.lastMoveEvent = event;\n      this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n      // Throttle mouse move event to once per frame\n      frame.update(this.updatePoint, true);\n    };\n    this.handlePointerUp = (event, info) => {\n      this.end();\n      const {\n        onEnd,\n        onSessionEnd,\n        resumeAnimation\n      } = this.handlers;\n      if (this.dragSnapToOrigin) resumeAnimation && resumeAnimation();\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n      const panInfo = getPanInfo(event.type === \"pointercancel\" ? this.lastMoveEventInfo : transformPoint(info, this.transformPagePoint), this.history);\n      if (this.startEvent && onEnd) {\n        onEnd(event, panInfo);\n      }\n      onSessionEnd && onSessionEnd(event, panInfo);\n    };\n    // If we have more than one touch, don't start detecting this gesture\n    if (!isPrimaryPointer(event)) return;\n    this.dragSnapToOrigin = dragSnapToOrigin;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    this.distanceThreshold = distanceThreshold;\n    this.contextWindow = contextWindow || window;\n    const info = extractEventInfo(event);\n    const initialInfo = transformPoint(info, this.transformPagePoint);\n    const {\n      point\n    } = initialInfo;\n    const {\n      timestamp\n    } = frameData;\n    this.history = [_objectSpread(_objectSpread({}, point), {}, {\n      timestamp\n    })];\n    const {\n      onSessionStart\n    } = handlers;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n  }\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n  end() {\n    this.removeListeners && this.removeListeners();\n    cancelFrame(this.updatePoint);\n  }\n}\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\nfunction getPanInfo(_ref, history) {\n  let {\n    point\n  } = _ref;\n  return {\n    point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\nfunction startDevicePoint(history) {\n  return history[0];\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\nexport { PanSession };","map":{"version":3,"names":["PanSession","constructor","event","handlers","transformPagePoint","contextWindow","window","dragSnapToOrigin","distanceThreshold","arguments","length","undefined","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","distance2D","offset","x","y","point","timestamp","frameData","push","_objectSpread","onStart","onMove","handlePointerMove","transformPoint","frame","update","handlePointerUp","end","onEnd","onSessionEnd","resumeAnimation","panInfo","type","isPrimaryPointer","extractEventInfo","initialInfo","onSessionStart","removeListeners","pipe","addPointerEvent","updateHandlers","cancelFrame","subtractPoint","a","b","_ref","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","timeDelta","i","timestampedPoint","lastPoint","secondsToMilliseconds","time","millisecondsToSeconds","currentVelocity","Infinity"],"sources":["C:\\Assigment\\portfolio\\node_modules\\framer-motion\\src\\gestures\\pan\\PanSession.ts"],"sourcesContent":["import type { EventInfo, PanHandler } from \"motion-dom\"\nimport { cancelFrame, frame, frameData, isPrimaryPointer } from \"motion-dom\"\nimport {\n    millisecondsToSeconds,\n    pipe,\n    Point,\n    secondsToMilliseconds,\n    TransformPoint,\n} from \"motion-utils\"\nimport { addPointerEvent } from \"../../events/add-pointer-event\"\nimport { extractEventInfo } from \"../../events/event-info\"\nimport { distance2D } from \"../../utils/distance\"\n\ninterface PanSessionHandlers {\n    onSessionStart: PanHandler\n    onStart: PanHandler\n    onMove: PanHandler\n    onEnd: PanHandler\n    onSessionEnd: PanHandler\n    resumeAnimation: () => void\n}\n\ninterface PanSessionOptions {\n    transformPagePoint?: TransformPoint\n    dragSnapToOrigin?: boolean\n    distanceThreshold?: number\n    contextWindow?: (Window & typeof globalThis) | null\n}\n\ninterface TimestampedPoint extends Point {\n    timestamp: number\n}\n\n/**\n * @internal\n */\nexport class PanSession {\n    /**\n     * @internal\n     */\n    private history: TimestampedPoint[]\n\n    /**\n     * @internal\n     */\n    private startEvent: PointerEvent | null = null\n\n    /**\n     * @internal\n     */\n    private lastMoveEvent: PointerEvent | null = null\n\n    /**\n     * @internal\n     */\n    private lastMoveEventInfo: EventInfo | null = null\n\n    /**\n     * @internal\n     */\n    private transformPagePoint?: TransformPoint\n\n    /**\n     * @internal\n     */\n    private handlers: Partial<PanSessionHandlers> = {}\n\n    /**\n     * @internal\n     */\n    private removeListeners: Function\n\n    /**\n     * For determining if an animation should resume after it is interupted\n     *\n     * @internal\n     */\n    private dragSnapToOrigin: boolean\n\n    /**\n     * The distance after which panning should start.\n     *\n     * @internal\n     */\n    private distanceThreshold: number\n\n    /**\n     * @internal\n     */\n    private contextWindow: PanSessionOptions[\"contextWindow\"] = window\n\n    constructor(\n        event: PointerEvent,\n        handlers: Partial<PanSessionHandlers>,\n        {\n            transformPagePoint,\n            contextWindow = window,\n            dragSnapToOrigin = false,\n            distanceThreshold = 3,\n        }: PanSessionOptions = {}\n    ) {\n        // If we have more than one touch, don't start detecting this gesture\n        if (!isPrimaryPointer(event)) return\n\n        this.dragSnapToOrigin = dragSnapToOrigin\n        this.handlers = handlers\n        this.transformPagePoint = transformPagePoint\n        this.distanceThreshold = distanceThreshold\n        this.contextWindow = contextWindow || window\n\n        const info = extractEventInfo(event)\n        const initialInfo = transformPoint(info, this.transformPagePoint)\n        const { point } = initialInfo\n\n        const { timestamp } = frameData\n\n        this.history = [{ ...point, timestamp }]\n\n        const { onSessionStart } = handlers\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history))\n\n        this.removeListeners = pipe(\n            addPointerEvent(\n                this.contextWindow,\n                \"pointermove\",\n                this.handlePointerMove\n            ),\n            addPointerEvent(\n                this.contextWindow,\n                \"pointerup\",\n                this.handlePointerUp\n            ),\n            addPointerEvent(\n                this.contextWindow,\n                \"pointercancel\",\n                this.handlePointerUp\n            )\n        )\n    }\n\n    private updatePoint = () => {\n        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return\n\n        const info = getPanInfo(this.lastMoveEventInfo, this.history)\n        const isPanStarted = this.startEvent !== null\n\n        // Only start panning if the offset is larger than 3 pixels. If we make it\n        // any larger than this we'll want to reset the pointer history\n        // on the first update to avoid visual snapping to the cursor.\n        const isDistancePastThreshold =\n            distance2D(info.offset, { x: 0, y: 0 }) >= this.distanceThreshold\n\n        if (!isPanStarted && !isDistancePastThreshold) return\n\n        const { point } = info\n        const { timestamp } = frameData\n        this.history.push({ ...point, timestamp })\n\n        const { onStart, onMove } = this.handlers\n\n        if (!isPanStarted) {\n            onStart && onStart(this.lastMoveEvent, info)\n            this.startEvent = this.lastMoveEvent\n        }\n\n        onMove && onMove(this.lastMoveEvent, info)\n    }\n\n    private handlePointerMove = (event: PointerEvent, info: EventInfo) => {\n        this.lastMoveEvent = event\n        this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint)\n\n        // Throttle mouse move event to once per frame\n        frame.update(this.updatePoint, true)\n    }\n\n    private handlePointerUp = (event: PointerEvent, info: EventInfo) => {\n        this.end()\n\n        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers\n\n        if (this.dragSnapToOrigin) resumeAnimation && resumeAnimation()\n        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return\n\n        const panInfo = getPanInfo(\n            event.type === \"pointercancel\"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint),\n            this.history\n        )\n\n        if (this.startEvent && onEnd) {\n            onEnd(event, panInfo)\n        }\n\n        onSessionEnd && onSessionEnd(event, panInfo)\n    }\n\n    updateHandlers(handlers: Partial<PanSessionHandlers>) {\n        this.handlers = handlers\n    }\n\n    end() {\n        this.removeListeners && this.removeListeners()\n        cancelFrame(this.updatePoint)\n    }\n}\n\nfunction transformPoint(\n    info: EventInfo,\n    transformPagePoint?: (point: Point) => Point\n) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info\n}\n\nfunction subtractPoint(a: Point, b: Point): Point {\n    return { x: a.x - b.x, y: a.y - b.y }\n}\n\nfunction getPanInfo({ point }: EventInfo, history: TimestampedPoint[]) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    }\n}\n\nfunction startDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n    return history[0]\n}\n\nfunction lastDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n    return history[history.length - 1]\n}\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n    if (history.length < 2) {\n        return { x: 0, y: 0 }\n    }\n\n    let i = history.length - 1\n    let timestampedPoint: TimestampedPoint | null = null\n    const lastPoint = lastDevicePoint(history)\n    while (i >= 0) {\n        timestampedPoint = history[i]\n        if (\n            lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)\n        ) {\n            break\n        }\n        i--\n    }\n\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 }\n    }\n\n    const time = millisecondsToSeconds(\n        lastPoint.timestamp - timestampedPoint.timestamp\n    )\n    if (time === 0) {\n        return { x: 0, y: 0 }\n    }\n\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    }\n\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0\n    }\n\n    return currentVelocity\n}\n"],"mappings":";;;;;;;AAiCA;;AAEG;MACUA,UAAU;EAuDnBC,YACIC,KAAmB,EACnBC,QAAqC,EAMZ;IAAA,IALzB;MACIC,kBAAkB;MAClBC,aAAa,GAAGC,MAAM;MACtBC,gBAAgB,GAAG,KAAK;MACxBC,iBAAiB,GAAG;IAAC,IAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MACF,EAAE;IAzD7B;;AAEG;IACK,IAAU,CAAAG,UAAA,GAAwB,IAAI;IAE9C;;AAEG;IACK,IAAa,CAAAC,aAAA,GAAwB,IAAI;IAEjD;;AAEG;IACK,IAAiB,CAAAC,iBAAA,GAAqB,IAAI;IAOlD;;AAEG;IACK,IAAQ,CAAAX,QAAA,GAAgC,EAAE;IAqBlD;;AAEG;IACK,IAAa,CAAAE,aAAA,GAAuCC,MAAM;IAoD1D,IAAW,CAAAS,WAAA,GAAG,MAAK;MACvB,IAAI,EAAE,IAAI,CAACF,aAAa,IAAI,IAAI,CAACC,iBAAiB,CAAC,EAAE;MAErD,MAAME,IAAI,GAAGC,UAAU,CAAC,IAAI,CAACH,iBAAiB,EAAE,IAAI,CAACI,OAAO,CAAC;MAC7D,MAAMC,YAAY,GAAG,IAAI,CAACP,UAAU,KAAK,IAAI;;;;MAK7C,MAAMQ,uBAAuB,GACzBC,UAAU,CAACL,IAAI,CAACM,MAAM,EAAE;QAAEC,CAAC,EAAE,CAAC;QAAEC,CAAC,EAAE;MAAC,CAAE,CAAC,IAAI,IAAI,CAAChB,iBAAiB;MAErE,IAAI,CAACW,YAAY,IAAI,CAACC,uBAAuB,EAAE;MAE/C,MAAM;QAAEK;MAAK,CAAE,GAAGT,IAAI;MACtB,MAAM;QAAEU;MAAS,CAAE,GAAGC,SAAS;MAC/B,IAAI,CAACT,OAAO,CAACU,IAAI,CAAAC,aAAA,CAAAA,aAAA,KAAMJ,KAAK;QAAEC;MAAS,EAAE,CAAC;MAE1C,MAAM;QAAEI,OAAO;QAAEC;MAAM,CAAE,GAAG,IAAI,CAAC5B,QAAQ;MAEzC,IAAI,CAACgB,YAAY,EAAE;QACfW,OAAO,IAAIA,OAAO,CAAC,IAAI,CAACjB,aAAa,EAAEG,IAAI,CAAC;QAC5C,IAAI,CAACJ,UAAU,GAAG,IAAI,CAACC,aAAa;;MAGxCkB,MAAM,IAAIA,MAAM,CAAC,IAAI,CAAClB,aAAa,EAAEG,IAAI,CAAC;IAC9C,CAAC;IAEO,KAAAgB,iBAAiB,GAAG,CAAC9B,KAAmB,EAAEc,IAAe,KAAI;MACjE,IAAI,CAACH,aAAa,GAAGX,KAAK;MAC1B,IAAI,CAACY,iBAAiB,GAAGmB,cAAc,CAACjB,IAAI,EAAE,IAAI,CAACZ,kBAAkB,CAAC;;MAGtE8B,KAAK,CAACC,MAAM,CAAC,IAAI,CAACpB,WAAW,EAAE,IAAI,CAAC;IACxC,CAAC;IAEO,KAAAqB,eAAe,GAAG,CAAClC,KAAmB,EAAEc,IAAe,KAAI;MAC/D,IAAI,CAACqB,GAAG,EAAE;MAEV,MAAM;QAAEC,KAAK;QAAEC,YAAY;QAAEC;MAAe,CAAE,GAAG,IAAI,CAACrC,QAAQ;MAE9D,IAAI,IAAI,CAACI,gBAAgB,EAAEiC,eAAe,IAAIA,eAAe,EAAE;MAC/D,IAAI,EAAE,IAAI,CAAC3B,aAAa,IAAI,IAAI,CAACC,iBAAiB,CAAC,EAAE;MAErD,MAAM2B,OAAO,GAAGxB,UAAU,CACtBf,KAAK,CAACwC,IAAI,KAAK,eAAe,GACxB,IAAI,CAAC5B,iBAAiB,GACtBmB,cAAc,CAACjB,IAAI,EAAE,IAAI,CAACZ,kBAAkB,CAAC,EACnD,IAAI,CAACc,OAAO,CACf;MAED,IAAI,IAAI,CAACN,UAAU,IAAI0B,KAAK,EAAE;QAC1BA,KAAK,CAACpC,KAAK,EAAEuC,OAAO,CAAC;;MAGzBF,YAAY,IAAIA,YAAY,CAACrC,KAAK,EAAEuC,OAAO,CAAC;IAChD,CAAC;;IA/FG,IAAI,CAACE,gBAAgB,CAACzC,KAAK,CAAC,EAAE;IAE9B,IAAI,CAACK,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACJ,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACI,iBAAiB,GAAGA,iBAAiB;IAC1C,IAAI,CAACH,aAAa,GAAGA,aAAa,IAAIC,MAAM;IAE5C,MAAMU,IAAI,GAAG4B,gBAAgB,CAAC1C,KAAK,CAAC;IACpC,MAAM2C,WAAW,GAAGZ,cAAc,CAACjB,IAAI,EAAE,IAAI,CAACZ,kBAAkB,CAAC;IACjE,MAAM;MAAEqB;IAAK,CAAE,GAAGoB,WAAW;IAE7B,MAAM;MAAEnB;IAAS,CAAE,GAAGC,SAAS;IAE/B,IAAI,CAACT,OAAO,GAAG,CAAAW,aAAA,CAAAA,aAAA,KAAMJ,KAAK;MAAEC;IAAS,GAAG;IAExC,MAAM;MAAEoB;IAAc,CAAE,GAAG3C,QAAQ;IACnC2C,cAAc,IACVA,cAAc,CAAC5C,KAAK,EAAEe,UAAU,CAAC4B,WAAW,EAAE,IAAI,CAAC3B,OAAO,CAAC,CAAC;IAEhE,IAAI,CAAC6B,eAAe,GAAGC,IAAI,CACvBC,eAAe,CACX,IAAI,CAAC5C,aAAa,EAClB,aAAa,EACb,IAAI,CAAC2B,iBAAiB,CACzB,EACDiB,eAAe,CACX,IAAI,CAAC5C,aAAa,EAClB,WAAW,EACX,IAAI,CAAC+B,eAAe,CACvB,EACDa,eAAe,CACX,IAAI,CAAC5C,aAAa,EAClB,eAAe,EACf,IAAI,CAAC+B,eAAe,CACvB,CACJ;;EA6DLc,cAAcA,CAAC/C,QAAqC;IAChD,IAAI,CAACA,QAAQ,GAAGA,QAAQ;;EAG5BkC,GAAGA,CAAA;IACC,IAAI,CAACU,eAAe,IAAI,IAAI,CAACA,eAAe,EAAE;IAC9CI,WAAW,CAAC,IAAI,CAACpC,WAAW,CAAC;;AAEpC;AAED,SAASkB,cAAcA,CACnBjB,IAAe,EACfZ,kBAA4C;EAE5C,OAAOA,kBAAkB,GAAG;IAAEqB,KAAK,EAAErB,kBAAkB,CAACY,IAAI,CAACS,KAAK;EAAC,CAAE,GAAGT,IAAI;AAChF;AAEA,SAASoC,aAAaA,CAACC,CAAQ,EAAEC,CAAQ;EACrC,OAAO;IAAE/B,CAAC,EAAE8B,CAAC,CAAC9B,CAAC,GAAG+B,CAAC,CAAC/B,CAAC;IAAEC,CAAC,EAAE6B,CAAC,CAAC7B,CAAC,GAAG8B,CAAC,CAAC9B;EAAC,CAAE;AACzC;AAEA,SAASP,UAAUA,CAAAsC,IAAA,EAAuBrC,OAA2B;EAAA,IAAjD;IAAEO;EAAK,CAAa,GAAA8B,IAAA;EACpC,OAAO;IACH9B,KAAK;IACL+B,KAAK,EAAEJ,aAAa,CAAC3B,KAAK,EAAEgC,eAAe,CAACvC,OAAO,CAAC,CAAC;IACrDI,MAAM,EAAE8B,aAAa,CAAC3B,KAAK,EAAEiC,gBAAgB,CAACxC,OAAO,CAAC,CAAC;IACvDyC,QAAQ,EAAEC,WAAW,CAAC1C,OAAO,EAAE,GAAG;GACrC;AACL;AAEA,SAASwC,gBAAgBA,CAACxC,OAA2B;EACjD,OAAOA,OAAO,CAAC,CAAC,CAAC;AACrB;AAEA,SAASuC,eAAeA,CAACvC,OAA2B;EAChD,OAAOA,OAAO,CAACA,OAAO,CAACR,MAAM,GAAG,CAAC,CAAC;AACtC;AAEA,SAASkD,WAAWA,CAAC1C,OAA2B,EAAE2C,SAAiB;EAC/D,IAAI3C,OAAO,CAACR,MAAM,GAAG,CAAC,EAAE;IACpB,OAAO;MAAEa,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAC,CAAE;;EAGzB,IAAIsC,CAAC,GAAG5C,OAAO,CAACR,MAAM,GAAG,CAAC;EAC1B,IAAIqD,gBAAgB,GAA4B,IAAI;EACpD,MAAMC,SAAS,GAAGP,eAAe,CAACvC,OAAO,CAAC;EAC1C,OAAO4C,CAAC,IAAI,CAAC,EAAE;IACXC,gBAAgB,GAAG7C,OAAO,CAAC4C,CAAC,CAAC;IAC7B,IACIE,SAAS,CAACtC,SAAS,GAAGqC,gBAAgB,CAACrC,SAAS,GAChDuC,qBAAqB,CAACJ,SAAS,CAAC,EAClC;MACE;;IAEJC,CAAC,EAAE;;EAGP,IAAI,CAACC,gBAAgB,EAAE;IACnB,OAAO;MAAExC,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAC,CAAE;;EAGzB,MAAM0C,IAAI,GAAGC,qBAAqB,CAC9BH,SAAS,CAACtC,SAAS,GAAGqC,gBAAgB,CAACrC,SAAS,CACnD;EACD,IAAIwC,IAAI,KAAK,CAAC,EAAE;IACZ,OAAO;MAAE3C,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAC,CAAE;;EAGzB,MAAM4C,eAAe,GAAG;IACpB7C,CAAC,EAAE,CAACyC,SAAS,CAACzC,CAAC,GAAGwC,gBAAgB,CAACxC,CAAC,IAAI2C,IAAI;IAC5C1C,CAAC,EAAE,CAACwC,SAAS,CAACxC,CAAC,GAAGuC,gBAAgB,CAACvC,CAAC,IAAI0C;GAC3C;EAED,IAAIE,eAAe,CAAC7C,CAAC,KAAK8C,QAAQ,EAAE;IAChCD,eAAe,CAAC7C,CAAC,GAAG,CAAC;;EAEzB,IAAI6C,eAAe,CAAC5C,CAAC,KAAK6C,QAAQ,EAAE;IAChCD,eAAe,CAAC5C,CAAC,GAAG,CAAC;;EAGzB,OAAO4C,eAAe;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport { isHTMLElement } from 'motion-dom';\nimport * as React from 'react';\nimport { useId, useRef, useContext, useInsertionEffect } from 'react';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { useComposedRefs } from '../../utils/use-composed-ref.mjs';\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component {\n  getSnapshotBeforeUpdate(prevProps) {\n    const element = this.props.childRef.current;\n    if (element && prevProps.isPresent && !this.props.isPresent) {\n      const parent = element.offsetParent;\n      const parentWidth = isHTMLElement(parent) ? parent.offsetWidth || 0 : 0;\n      const size = this.props.sizeRef.current;\n      size.height = element.offsetHeight || 0;\n      size.width = element.offsetWidth || 0;\n      size.top = element.offsetTop;\n      size.left = element.offsetLeft;\n      size.right = parentWidth - size.width - size.left;\n    }\n    return null;\n  }\n  /**\n   * Required with getSnapshotBeforeUpdate to stop React complaining.\n   */\n  componentDidUpdate() {}\n  render() {\n    return this.props.children;\n  }\n}\nfunction PopChild({\n  children,\n  isPresent,\n  anchorX,\n  root\n}) {\n  const id = useId();\n  const ref = useRef(null);\n  const size = useRef({\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0,\n    right: 0\n  });\n  const {\n    nonce\n  } = useContext(MotionConfigContext);\n  const composedRef = useComposedRefs(ref, children?.ref);\n  /**\n   * We create and inject a style block so we can apply this explicit\n   * sizing in a non-destructive manner by just deleting the style block.\n   *\n   * We can't apply size via render as the measurement happens\n   * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n   * styles directly on the DOM node, we might be overwriting\n   * styles set via the style prop.\n   */\n  useInsertionEffect(() => {\n    const {\n      width,\n      height,\n      top,\n      left,\n      right\n    } = size.current;\n    if (isPresent || !ref.current || !width || !height) return;\n    const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`;\n    ref.current.dataset.motionPopId = id;\n    const style = document.createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    const parent = root ?? document.head;\n    parent.appendChild(style);\n    if (style.sheet) {\n      style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            top: ${top}px !important;\n          }\n        `);\n    }\n    return () => {\n      if (parent.contains(style)) {\n        parent.removeChild(style);\n      }\n    };\n  }, [isPresent]);\n  return jsx(PopChildMeasure, {\n    isPresent: isPresent,\n    childRef: ref,\n    sizeRef: size,\n    children: React.cloneElement(children, {\n      ref: composedRef\n    })\n  });\n}\nexport { PopChild };","map":{"version":3,"names":["PopChildMeasure","React","Component","getSnapshotBeforeUpdate","prevProps","element","isPresent","props","parent","offsetParent","parentWidth","isHTMLElement","offsetWidth","size","top","offsetTop","left","offsetLeft","right","width","componentDidUpdate","children","PopChild","anchorX","root","id","useId","ref","useRef","height","current","x","nonce","style","document","head","appendChild","sheet","insertRule","contains","removeChild","jsx","childRef","sizeRef","cloneElement","composedRef"],"sources":["C:\\Assigment\\portfolio\\node_modules\\framer-motion\\src\\components\\AnimatePresence\\PopChild.tsx"],"sourcesContent":["\"use client\"\n\nimport { isHTMLElement } from \"motion-dom\"\nimport * as React from \"react\"\nimport { useContext, useId, useInsertionEffect, useRef } from \"react\"\n\nimport { MotionConfigContext } from \"../../context/MotionConfigContext\"\nimport { useComposedRefs } from \"../../utils/use-composed-ref\"\n\ninterface Size {\n    width: number\n    height: number\n    top: number\n    left: number\n    right: number\n}\n\ninterface Props {\n    children: React.ReactElement\n    isPresent: boolean\n    anchorX?: \"left\" | \"right\"\n    root?: HTMLElement | ShadowRoot\n}\n\ninterface MeasureProps extends Props {\n    childRef: React.RefObject<HTMLElement | null>\n    sizeRef: React.RefObject<Size>\n}\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component<MeasureProps> {\n    getSnapshotBeforeUpdate(prevProps: MeasureProps) {\n        const element = this.props.childRef.current\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const parent = element.offsetParent\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0\n\n            const size = this.props.sizeRef.current!\n            size.height = element.offsetHeight || 0\n            size.width = element.offsetWidth || 0\n            size.top = element.offsetTop\n            size.left = element.offsetLeft\n            size.right = parentWidth - size.width - size.left\n        }\n\n        return null\n    }\n\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() {}\n\n    render() {\n        return this.props.children\n    }\n}\n\nexport function PopChild({ children, isPresent, anchorX, root }: Props) {\n    const id = useId()\n    const ref = useRef<HTMLElement>(null)\n    const size = useRef<Size>({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n    })\n    const { nonce } = useContext(MotionConfigContext)\n    const composedRef = useComposedRefs(\n        ref,\n        (children as { ref?: React.Ref<HTMLElement> })?.ref\n    )\n\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right } = size.current\n        if (isPresent || !ref.current || !width || !height) return\n\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`\n\n        ref.current.dataset.motionPopId = id\n\n        const style = document.createElement(\"style\")\n        if (nonce) style.nonce = nonce\n\n        const parent = root ?? document.head\n        parent.appendChild(style)\n\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            top: ${top}px !important;\n          }\n        `)\n        }\n\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style)\n            }\n        }\n    }, [isPresent])\n\n    return (\n        <PopChildMeasure isPresent={isPresent} childRef={ref} sizeRef={size}>\n            {React.cloneElement(children as any, { ref: composedRef })}\n        </PopChildMeasure>\n    )\n}\n"],"mappings":";;;;;;;;;AA6BA;;;AAGG;AACH,MAAAA,eAAA,SAAAC,KAAA,CAAAC,SAAA;EACIC,wBAAAC,SAAA;;IAEI,IAAAC,OAAA,IAAAD,SAAA,CAAAE,SAAA,UAAAC,KAAA,CAAAD,SAAA;MACI,MAAAE,MAAA,GAAAH,OAAA,CAAAI,YAAA;MACA,MAAAC,WAAA,GAAAC,aAAA,CAAAH,MAAA,IACIA,MAAA,CAAAI,WAAA,Q;;;;MAMJC,IAAA,CAAAC,GAAA,GAAAT,OAAA,CAAAU,SAAA;MACAF,IAAA,CAAAG,IAAA,GAAAX,OAAA,CAAAY,UAAA;MACAJ,IAAA,CAAAK,KAAA,GAAAR,WAAA,GAAAG,IAAA,CAAAM,KAAA,GAAAN,IAAA,CAAAG,IAAA;;IAGJ;;EAGJ;;AAEG;EACHI,mBAAA;;IAGI,YAAAb,KAAA,CAAAc,QAAA;;AAEP;AAEK,SAAAC,SAAA;EAAAD,QAAA;EAAAf,SAAA;EAAAiB,OAAA;EAAAC;AAAA;EACF,MAAAC,EAAA,GAAAC,KAAA;EACA,MAAAC,GAAA,GAAAC,MAAA;;IAEIT,KAAA;IACAU,MAAA;IACAf,GAAA;IACAE,IAAA;IACAE,KAAA;EACH;;;;;EAOD;;;;;;;;AAQG;;IAEC;MAAAC,KAAA;MAAAU,MAAA;MAAAf,GAAA;MAAAE,IAAA;MAAAE;IAAA,IAAAL,IAAA,CAAAiB,OAAA;;IAGA,MAAAC,CAAA,GAAAR,OAAA,uBAAAP,IAAA,eAAAE,KAAA;;;IAKA,IAAAc,KAAA,EAAWC,KAAA,CAAAD,KAAA,GAAAA,KAAA;IAEX,MAAAxB,MAAA,GAAAgB,IAAA,IAAAU,QAAA,CAAAC,IAAA;IACA3B,MAAA,CAAA4B,WAAA,CAAAH,KAAA;IAEA,IAAAA,KAAA,CAAAI,KAAA;MACIJ,KAAA,CAAAI,KAAA,CAAAC,UAAA;;;;;;;;AAQH;;IAGD;MACI,IAAA9B,MAAA,CAAA+B,QAAA,CAAAN,KAAA;QACIzB,MAAA,CAAAgC,WAAA,CAAAP,KAAA;;IAER;EACJ,IAAA3B,SAAA;EAEA,OAAAmC,GAAA,CAAAzC,eAAA;IAAAM,SAAA,EAAAA,SAAA;IAAAoC,QAAA,EAAAf,GAAA;IAAAgB,OAAA,EAAA9B,IAAA;IAAAQ,QAAA,EAAApB,KAAA,CAAA2C,YAAA,CAAAvB,QAAA;MAAAM,GAAA,EAAAkB;IAAA;EAAA;AAKJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}